---
title: "連載：tidyverse"
author: "Momoko Ichinokawa"
date: "`r Sys.Date()`"
output:
  md_document
---

```{r, echo=FALSE}
library(knitr)
library(rmarkdown)
library(tidyverse)
#render("text.Rmd")

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
#                     cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
#opts_knit$set(width=75)
par(mar=c(4,4,3,1))
```
# 1週目

## １回目：趣旨
tidyverseって知ってますか？Rから呼び出せる一連の「便利パッケージ」を集めたメタパッケージのことです。非常に便利なので、VPA計算や将来予測ツールを提供しているfrasyrも、今後、tidyverseをどんどん取り入れていく方針に転換しています。普通にRを使って自分のデータ解析をしている人だけでなく、frasyrパッケージを使って資源計算されている人も、ぜひtidyverseの世界を知ってほしいと思っています。

それによって

- 整理されたデータ（整然データ、今後解説）を使った一連のデータ処理プロセスの固定化・単純化→研究の効率アップ
- tidyverseの標準グラフィックスシステムであるggplot2を使った効率的なグラフ作成→研究の効率アップ
- frasyr, frasyr_toolのバグ発見や修正依頼、さらには拡張コードを書くことへの障壁が少なく→皆でfrasyrを共同開発

のような効果が期待できます。

ここではできるだけ1回で１トピック、tidyverseで使うパッケージや関数の使い方、従来のR（裸のRと呼ぶことも）との違いなんかを、書きき込んでいきます。その後、何か思うところあったら、または追加の情報などをコメントとして返信してもらうことで、勉強を進めていければと思います。

今後想定するトピックとしては
- tidy data（整然データ）とは何か？
- パイプ %>%の使い方
- ggplot2
- データ成型用パッケージ dplyr を使ったデータの整理
- などなど
です。私も細かいことあまり知らないので、より分かっている人にさらに解説してもらったりできればうれしいです。

初回は参考URLを示すことで終わりにします。来週からぽつぽつアップしますので、よろしくお願いします。

- 本家のサイト　https://r4ds.had.co.nz/　英語だけど本一冊分が無料で読めます。これを１冊通して読めばtidyverseマスター！
- 上のサイトの日本語訳　https://www.amazon.co.jp/R%E3%81%A7%E3%81%AF%E3%81%98%E3%82%81%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9-Hadley-Wickham/dp/487311814X
- tidyverseの概説とさらなる参考情報　https://heavywatal.github.io/rstats/programming.html

## 2回目：インストールと使い方

tidyverseの世界に入るときに一番最初にやること、、それは、tidyverseパッケージのインストールです。パッケージのインストール方法はいろいろありますが、コピペで済むのでここでは以下のコマンドでインストールすることにします。コマンドを打つと、「どこのサーバーからパッケージをダウンロードするか？」を聞かれることがあるので、そこはJapan(Tokyo)を選んで（多分どこを選んでもよい）、インストールします。複数のパッケージを同時にインストールするので時間がかかります。

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyverse")
```

無事インストールが終わったら、以下のコマンドを打ってパッケージを呼び出してみましょう。
```{r, echo=TRUE}
library(tidyverse)
```
すると、あまり見慣れない \-\- Attaching packages \-\- とかいう表記が出てきます。

\-\- Attaching packagesの下は、tidyverseをlibraryしたことで呼び出されるパッケージの一覧（tidyverseは複数のパッケージを寄せ集めたメタパッケージなので）とそれぞれのパッケージのバージョン番号を示しています。

\-\- Conflictの下には、tidyverseパッケージを呼び出すことで生じた関数名のコンフリクト（異なるパッケージ間で同じ関数名が使われている）の一覧が示されています。 x dplyr::filter() masks stats::filter() は、「パッケージdplyrとstatの両方でfilterという関数が定義されているけど、ここでは単にfilterを呼ぶ場合はdplyrのfilterを使いますよ」という意味です。

また、ここで出てくる「::」は、用いる関数名がなんのパッケージ由来のものかを明示的に示すための記号です（つまり　**パッケージ名::関数名** ）。この方法で関数を指定すれば、library(パッケージ名)という形であらかじめパッケージを呼び出しておかなくても、自分の環境内にインストールされたパッケージの中の関数を利用することができます。逆に、**パッケージ名::** なんてつけるのめんどくさいという人は、あらかじめ自分が使う関数をlibraryで呼び出しておけばいいわけです。ただし、上記のように、複数のパッケージ間で同じ関数名を使う場合はコンフリクトがおこるので（どういう状況でどちらのパッケージが優先されるかは？なんですが）、関数が意図下通りに動かずにエラーやバグが生じる恐れがあります。特に、dplyrのfilterは非常によく使い関数なんですが、statsパッケージのfilterと同名の関数になっているため、ライブラリの呼び出しの順番によってfilterがstatsのfilterになったりdplyrのfilterになったりします。ので、filterだけにはdplyr::filterとして使ったほうが良いかと思います。

```{r, echo=TRUE}
## ::の例 (まだtidyverseをlibraryしていない状況下でお試しください）

# パッケージtibble内にある関数tibbleを使う
# ::をつければlibraryする必要はない
data_test <- tibble::tibble(a=1:5, b=2:6)

# パッケージ内の関数を呼び出してから使う場合
# libraryしてあるので::は必要ない
library(tibble)  # or library(tidyverse)
data_test <- tibble(ax=1:5, bx=2:6)
```

（**注** frasyrやfrasyr_toolでは、tidyverse内の関数をすべて「パッケージ名::関数名」としてはいません（かわりに、Rコードの最初でlibrary(tidyverse)をする必要があります）。ただし、dplyr::filterなど、コンフリクトが起こりそうな関数については::をつけています。また、gridExtraやforeachなど、使用頻度の高くないパッケージについては::をつけて呼び出しています。）

最後、ちょっとマニアックな話になりましたが、たまに目にする::の意味を知らないと、Rのコードを読んでいて::に遭遇したときの不安感が非常に大きいと思いますので、少し説明してみました。

次回は、tidyverseの中のパッケージがそれぞれ何をしているかの概要をお話しします。

## 3日目：tidyverseの中身と代表的な便利関数

いよいよtidyverseをインストールしました。3回目は、tidyverseで呼び出される複数のパッケージの中で、従来関数と互換性のある、でも、tidyverseのほうがちょっと便利な関数を紹介します。既存のR関数との比較はRをすでにけっこう知っている人向けの解説なので、R初修者はわからなくても気にしなくてもいいです。

### パッケージ：tibble

データを格納する形式である **tibble (←→ data.frame)** を提供。

**Q1**: tibbleとdata.frameの違いを比較してみよう！

```{r, echo=TRUE}
dat_f <- data.frame(a=1:100, b=rnorm(100))  # 100行2列のデータフレームを作る
dat_t <- tibble::tibble(a=1:100, b=rnorm(100))  # 上と同じ操作
dat_f
dat_t
```

**A1**: 中身はほとんど同じだけど、中身を表示させたときの挙動が違うよ。通常のdata.frameは、全データを単純に全部出力しようとします。一方、tibbleの場合は行数や列数が長すぎるばあいは途中で省略し（# ... with 90 more rows（それとあと90行）, という表記）、また、冒頭にデータフレームの構造（# A tibble: 100x2 (100列２行のtibble形式の行列、それぞれの列の「型」がなんであるか（<int>(整数) <dbl>(連続数)など）の情報を出力します。

あと、リストを作成する **lst (←→ list)** も便利だということを最近知りました。

**Q2**: lstとlistの違いを比較してみよう！

```{r, echo=TRUE}
a <- 1:10
b <- c("char1","char2","char3")
list_list <- list(a,b)
list_lst  <- tibble::lst(a,b)
list_list
list_lst
```

**A2**: オブジェクトをまとめてリストにしたとき、lstは自動的にもともとのオブジェクトの名前がつくよ。関数の返り値をリスト形式にして返すとき、地味に便利です。

### パッケージ：readr
Rのパッケージの名前って、「機能」を示す単語＋r（R）というふうにつけるのが今風らしいです。なので、readrも、read + rと考えると、何かを「読む」ためのパッケージだということがわかります。同様に、stringrはstring + rなので、文字列を処理するための関数とわかります。（frasyrもそれにならって、FRA \+ SY (sustainable yield) \+ rということでつけてみました。）

readrはデータの入出力のための **read_csv( ←→ read.csv)**,  **write_csv (←→ write.csv)** などを提供しています。

**Q3**: read_csvとread.csvの違いを比較してみよう！

```{r, echo=TRUE}
write_csv(tibble(a=1:10, b=rnorm(10)), path="test.csv") # 読み込むためのデータを出力しておく
dat_read1 <- read.csv("test.csv")
dat_read2 <- readr::read_csv("test.csv")
```

**A3**: read_csvを使ってデータの読み込みに成功すると、読み込んだデータの概要を表示してくれます。また、読み込まれたデータは自動的にtibble形式になります。

## その他パッケージ

その他パッケージは追い追い紹介していきますが、いちおう以下に一覧表を作ってみました。

### 表：tidyverseが提供するパッケージと代表的な機能

|パッケージ名  |説明  |代表的な関数(括弧内は、tidyverseを使わない場合のRの関数) |
|---|---|---|
|tibble |より柔軟な形式のデータフレーム`tibble`等を提供 | データフレームを作成:`tibble` (`data.frame`), データをtibble形式に変換:`as_tibble`, リストを作成: `lst`(list) |
|tidyr |データを横長データから縦長データへ、縦長データから横長データへ変換する|横長データを縦長データに変換する: `gather` (`as.data.frame.table`), 縦長データを横長データに変換する: `spread` (`tapply`)|
|dplyr |データを整形したり、変換したりする | 列を抽出: `select`, 行を抽出: `filter`(`subset`), 列を追加または変更: `mutate`, データの並び替え: `arrange` (`sort`,`order`), パイプ演算子: `%>%`(詳細はBOX) |
|readr |データの読み込みと出力。読んだデータはtibble形式となる。 |`read_table`(`read.table`), `read_csv`(`read.csv`), `write_table`(`write.table`), `write_csv`(`write.csv`) |
|stringr |文字列操作| `str_`で始まる関数群。文字列結合: `str_c`(`paste`)|
|forcats |カテゴリカル変数を取扱う | `fct_`で始まる関数群。他の変数を使ってカテゴリカル要素の順番(level)を付け替える: `fct_reorder`, 登場頻度が多い（少ない）順にlevelを付け替える: `fct_infreq`|
|purrr |ループ処理やapply系関数 |`map_`で始まる関数群。各要素に関数を適用: `map`(`lapply`), mapしたのちにdata.frameとして結合: `map_dfr` (`sapply`) |	 
|ggplot2 |グラフ作成（詳細は後日) |`ggplot`, `geom_`で始まる関数群 |

次回は、上の表にある「縦長データ」「横長データ」について解説します。

### どうでもいい？雑談： \. と \_ の違いについて

裸のRの関数名は単語と単語の間を\.で区切るものが多いです。一方、今風のRの関数は\_で区切るものが主流です。\.の関数名はちょっと古い関数（または、メソッドという特別な機能が付与された関数）で、\_の関数名は新しめの関数と覚えておくと便利です（frasyrでもそうです）。

なぜ、\.から\_へのシフトがおこったんでしょう？

20年前からRを使っていた人は、オブジェクトや関数の名前に絶対\_を入れませんでした。というのは、昔、Rでは \_ が「代入記号」として利用されていたんです。なんで、うっかり `dat_1` なんて書いてしまうと、`dat <- 1` または`dat = 1`と同じ動きをして、プログラムがめちゃくちゃになったのです、、。

しかし、 この仕様はかなり昔に変更され、あと、プログラミングの [命名規約](https://ja.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0) ) では\_を使うほうが良いということもあり、私もようやく最近オブジェクト名に \_を使えるようになりました。

ということで、frasyrでも、関数名やオブジェクト名に\.と\_が混在していますが、\.で区切られた名前の関数はたいてい古く、\_で区切られた名前の関数や関数の引数は比較的最近作られた関数だと区別してください（上に紹介したread.csvとread_csvの違いのように）。たとえば、frasyrにはplot.futuresとplot_futuresという関数がありますが、前者は裸のRで書かれた古い（素朴な）関数で、後者はggplot2で書かれた新しい関数です。

（\.で区切られた関数名は「メソッド」という新しい別の機能が付与されるため、けっこう使いづらく、最近ではむしろ避けられています。）

<!---

## ４日目：tidy dataとは？

## ５日目：tidy data と dplyr

## 6日目：データの縦横変換

## 7日目：ggplot2とtidyverse (1)

## 8日目：ggplot2とtidyverse (2)

--->
